内容卡片（Feed Card）设计文档

— 仿微信公众号风格 · 可复用组件设计 —

1. 设计背景与目标
1.1 背景

当前首页 index.astro 直接在页面中实现了内容卡片（feed-card）：

数据获取、摘要提取、渲染结构、样式全部耦合在一个页面

随着内容来源增加（博客 / 外部平台 / Feed 聚合），该结构将不可维护

当前卡片样式已基本稳定，具备抽象为「可复用组件」的条件

1.2 设计目标

本次任务的目标不是“重构代码”，而是为未来的组件化建立清晰边界：

明确「内容卡片」是什么、负责什么、不负责什么

为后续抽离成组件（FeedCard.astro / FeedList.astro）做准备

保持当前微信公众号 / Medium 风格的阅读体验

2. 内容卡片的设计理念（仿微信公众号）

参考对象：
微信公众号 / 知乎 / Medium 首页内容流

这些平台的共同点是：

卡片不是“文章的一部分”，而是文章的“入口”

卡片内容必须：

信息密度稳定

高度可扫描（scan-friendly）

不受原始 Markdown 排版影响

核心设计原则

卡片展示的是“语义内容”，不是 Markdown

高度可预测（不因为文章写法而破坏布局）

卡片高度应在视觉上尽量一致

3. 卡片信息结构定义（逻辑结构）
3.1 卡片的最小信息单元

当前版本的卡片定义为：

FeedCard
├─ publishedAt   发布时间（必选）
├─ title         标题（必选）
├─ excerpt       摘要（必选，纯文本）
└─ url           跳转链接（必选）


这是一个**“入口型卡片”**，不承载作者、标签、互动数据等信息。

3.2 展示顺序（严格固定）

视觉顺序 不可变：

发布时间

标题（可点击）

摘要（两行，自动省略）

原因：

用户已形成阅读惯性（尤其是中文用户）

时间是内容判断的第一锚点

标题 > 摘要 的视觉权重不可颠倒

4. 摘要（Excerpt）设计说明
4.1 为什么不能直接使用 Markdown 内容

原始 Markdown 存在以下问题：

标题符号（#）、列表符号、强调符号污染视觉

内容长度不可控，导致卡片高度不稳定

极短文章会导致“空卡片”

因此采用 摘要提取函数（extractExcerpt）。

4.2 摘要生成策略（当前方案）

摘要生成遵循：

去除 Markdown 语法，仅保留纯文本

控制长度区间：

minLength: 防止内容过短导致视觉空洞

maxLength: 防止摘要过长

超出长度时追加省略号（…）

这与主流内容平台一致：

服务端 / 构建期裁剪内容

客户端仅负责视觉裁剪（行数）

5. 卡片视觉设计规范
5.1 卡片容器

白色（Light）/ 深灰（Dark）背景

圆角

轻边框

极弱阴影（Dark 模式无阴影）

卡片的视觉目标是：

“像纸片一样浮在内容流中，但不抢戏”

5.2 摘要行数策略

使用 CSS 行数截断（line-clamp: 2）

永远展示 正好两行

多余内容由 CSS 截断，而不是 JS 动态计算

这是一个刻意的设计选择：

行数 ≠ 字数

行数才是视觉稳定的唯一标准

6. 当前实现的职责划分（非常重要）
6.1 index.astro 当前承担的职责
职责	是否合理
获取内容集合	✅
排序	✅
调用摘要提取	✅
渲染卡片结构	⚠️（后续抽离）
定义卡片样式	⚠️（后续抽离）
6.2 未来组件化的方向（不立即实现）

预期的演进路径：

FeedList
└─ FeedCard
   ├─ Meta（时间）
   ├─ Title
   └─ Excerpt


页面只负责“给数据”

组件负责“怎么展示”

样式不再散落在页面中

7. 非目标（刻意不做的事情）

以下内容明确不在本阶段设计范围内：

❌ 封面图（thumbnail）

❌ 作者头像

❌ 阅读数 / 点赞数

❌ 标签 / 分类

❌ 卡片内交互（hover 动效除外）

这些都属于 V2 / V3 扩展能力。

8. 设计总结（一句话版）

内容卡片不是文章本身，而是文章的“稳定入口”。
它牺牲自由排版，换取可扫描性、可预测性与系统一致性。